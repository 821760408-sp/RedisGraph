{
    "docs": [
        {
            "location": "/", 
            "text": "Redis Graph\n\n\nThis project is a Redis module that implements a graph database. Nodes in the graph represent entities such as persons or places, and connections such as 'visit' are made between the different entities.\n\n\nSuppose we had a person entity representing Barack Obama, it might have two attributes: \"age\" (55) and \"profession\" (ex-president). We could also have another entity represent Hawaii with an attribute \"population\" (1442949). Finally we could construct a simple graph by connecting Barack Obama with an edge representing the relation \"born\" with Hawaii.\n\n\nPrimary features:\n\n\n\n\nA graph database implementation\n\n\nNodes and edges may have attributes\n\n\nNodes and edges can be labeled\n\n\nSupports Neo4j's \nopenCypher\n queries\n\n\n\n\nTo see Redis Graph in action see \nDemos\n.\n\n\nQuickstart\n\n\n\n\nBuild the Redis Graph module library\n\n\nLoad Redis Graph to Redis\n\n\nUse it from any client\n\n\n\n\nBuilding the module\n\n\nLinux Ubuntu 16.04\n\n\nRequirements:\n\n\n\n\nThe Redis Graph repository: \ngit clone https://github.com/RedisLabsModules/redis-module-graph.git\n\n\nThe build-essential and cmake packages: \napt-get install build-essential cmake\n\n\n\n\nTo build the module, run the following in the project's directory:\n\n\ncmake . \n make module\n\n\n\n\n\nCongratulations! You can find the compiled module library at \nsrc/libmodule.so\n.\n\n\nLoading the module to Redis\n\n\nRequirements:\n\n\n\n\nRedis v4.0 or above\n\n\n\n\nWe recommend you have Redis load the module during startup by adding the following to your redis.conf file:\n\n\nloadmodule /path/to/module/libmodule.so\n\n\n\n\n\nIn the line above replace \n/path/to/module/libmodule.so\n with the actual path to the module's library. Alternatively, you can have Redis load the module using the following command line argument syntax:\n\n\n~/$ redis-server --loadmodule /path/to/module/libmodule.so\n\n\n\n\n\nLastly, you can also use the \nMODULE LOAD\n command. Note, however, that \nMODULE LOAD\n is a dangerous command and may be blocked/deprecated in the future due to security considerations.\n\n\nOnce the module has been loaded successfully, the Redis log should have lines similar to:\n\n\n...\n30707:M 20 Jun 02:08:12.314 * Module \ngraph\n loaded from \nredacted\n/src/libmodule.so\n...\n\n\n\n\n\nUsing Redis Graph\n\n\nBefore using Redis Graph, you should familiarize yourself with its commands and syntax as detailed in the \ncommands reference\n document.\n\n\nYou can call Redis Graph's commands from any Redis client.\n\n\nWith \nredis-cli\n\n\n$ redis-cli\n\n127\n.0.0.1:6379\n GRAPH.CREATENODE social person name roi age \n32\n gender male status married\n\n459034279876493568\n\n\n\n\n\n\nWith any other client\n\n\nYou can call the module's API using your client's ability to send raw Redis commands. Depending on your client of choice, the exact method for doing that may vary.\n\n\nPython example\n\n\nThis code snippet shows how to use Redis Graph with raw Redis commands from Python with \nredis-py\n:\n\n\nimport\n \nredis\n\n\n\nr\n \n=\n \nredis\n.\nStrictRedis\n()\n\n\nreply\n \n=\n \nr\n.\nexecute_command\n(\nGRAPH.CREATENODE\n,\n \nsocial\n,\n \nperson\n,\n \nname\n,\n \nroi\n,\n \nage\n,\n \n32\n,\n \ngender\n,\n \nmale\n,\n \nstatus\n,\n \nmarried\n)\n\n\n\n\n\n\nClient libraries\n\n\nSome languages have client libraries that provide support for Redis Graph's commands:\n\n\n\n\n\n\n\n\nProject\n\n\nLanguage\n\n\nLicense\n\n\nAuthor\n\n\nURL\n\n\n\n\n\n\n\n\n\n\nTBD\n\n\nPython\n\n\nTBD\n\n\nRedis Labs\n\n\nGitHub", 
            "title": "Quickstart"
        }, 
        {
            "location": "/#redis-graph", 
            "text": "This project is a Redis module that implements a graph database. Nodes in the graph represent entities such as persons or places, and connections such as 'visit' are made between the different entities.  Suppose we had a person entity representing Barack Obama, it might have two attributes: \"age\" (55) and \"profession\" (ex-president). We could also have another entity represent Hawaii with an attribute \"population\" (1442949). Finally we could construct a simple graph by connecting Barack Obama with an edge representing the relation \"born\" with Hawaii.  Primary features:   A graph database implementation  Nodes and edges may have attributes  Nodes and edges can be labeled  Supports Neo4j's  openCypher  queries   To see Redis Graph in action see  Demos .", 
            "title": "Redis Graph"
        }, 
        {
            "location": "/#quickstart", 
            "text": "Build the Redis Graph module library  Load Redis Graph to Redis  Use it from any client", 
            "title": "Quickstart"
        }, 
        {
            "location": "/#building-the-module", 
            "text": "", 
            "title": "Building the module"
        }, 
        {
            "location": "/#linux-ubuntu-1604", 
            "text": "Requirements:   The Redis Graph repository:  git clone https://github.com/RedisLabsModules/redis-module-graph.git  The build-essential and cmake packages:  apt-get install build-essential cmake   To build the module, run the following in the project's directory:  cmake .   make module  Congratulations! You can find the compiled module library at  src/libmodule.so .", 
            "title": "Linux Ubuntu 16.04"
        }, 
        {
            "location": "/#loading-the-module-to-redis", 
            "text": "Requirements:   Redis v4.0 or above   We recommend you have Redis load the module during startup by adding the following to your redis.conf file:  loadmodule /path/to/module/libmodule.so  In the line above replace  /path/to/module/libmodule.so  with the actual path to the module's library. Alternatively, you can have Redis load the module using the following command line argument syntax:  ~/$ redis-server --loadmodule /path/to/module/libmodule.so  Lastly, you can also use the  MODULE LOAD  command. Note, however, that  MODULE LOAD  is a dangerous command and may be blocked/deprecated in the future due to security considerations.  Once the module has been loaded successfully, the Redis log should have lines similar to:  ...\n30707:M 20 Jun 02:08:12.314 * Module  graph  loaded from  redacted /src/libmodule.so\n...", 
            "title": "Loading the module to Redis"
        }, 
        {
            "location": "/#using-redis-graph", 
            "text": "Before using Redis Graph, you should familiarize yourself with its commands and syntax as detailed in the  commands reference  document.  You can call Redis Graph's commands from any Redis client.", 
            "title": "Using Redis Graph"
        }, 
        {
            "location": "/#with-redis-cli", 
            "text": "$ redis-cli 127 .0.0.1:6379  GRAPH.CREATENODE social person name roi age  32  gender male status married 459034279876493568", 
            "title": "With redis-cli"
        }, 
        {
            "location": "/#with-any-other-client", 
            "text": "You can call the module's API using your client's ability to send raw Redis commands. Depending on your client of choice, the exact method for doing that may vary.", 
            "title": "With any other client"
        }, 
        {
            "location": "/#python-example", 
            "text": "This code snippet shows how to use Redis Graph with raw Redis commands from Python with  redis-py :  import   redis  r   =   redis . StrictRedis ()  reply   =   r . execute_command ( GRAPH.CREATENODE ,   social ,   person ,   name ,   roi ,   age ,   32 ,   gender ,   male ,   status ,   married )", 
            "title": "Python example"
        }, 
        {
            "location": "/#client-libraries", 
            "text": "Some languages have client libraries that provide support for Redis Graph's commands:     Project  Language  License  Author  URL      TBD  Python  TBD  Redis Labs  GitHub", 
            "title": "Client libraries"
        }, 
        {
            "location": "/commands/", 
            "text": "Redis Graph Commands\n\n\nGRAPH.CREATENODE\n\n\nCreates a new node within the given graph, marked with a label (if provided).\n\n\nArguments: \nGraph name, label [optional], list of key value attributes\n\n\nReturns: \nNode ID\n\n\nGRAPH.CREATENODE us_government president name \nBarack Obama\n age \n55\n\n\n\n\n\n\nGRAPH.ADDEDGE\n\n\nCreates a connection within the given graph between source node and destination node, using relation.\n\n\nArguments: \nGraph name, source node ID, relationship, destination node ID\n\n\nReturns: \nEdge ID\n\n\nGRAPH.ADDEDGE us_government Barak_Obama_Node_ID born Hawaii_Node_ID", 
            "title": "Commands"
        }, 
        {
            "location": "/commands/#redis-graph-commands", 
            "text": "", 
            "title": "Redis Graph Commands"
        }, 
        {
            "location": "/commands/#graphcreatenode", 
            "text": "Creates a new node within the given graph, marked with a label (if provided).  Arguments:  Graph name, label [optional], list of key value attributes  Returns:  Node ID  GRAPH.CREATENODE us_government president name  Barack Obama  age  55", 
            "title": "GRAPH.CREATENODE"
        }, 
        {
            "location": "/commands/#graphaddedge", 
            "text": "Creates a connection within the given graph between source node and destination node, using relation.  Arguments:  Graph name, source node ID, relationship, destination node ID  Returns:  Edge ID  GRAPH.ADDEDGE us_government Barak_Obama_Node_ID born Hawaii_Node_ID  <!--## GRAPH.REMOVEEDGE\n\nRemoves edge connecting source to destination.\n\nArguments: `Graph name, source node ID, relationship, destination node ID`\n\nReturns: `Null`\n\n\n\u0002wzxhzdk:2\u0003\n\n\n## GRAPH.EXPLAIN\n\nConstructs a query execution plan but does not run it. Inspect this execution plan to better\nunderstand how your query will get executed.\n\nArguments: `Graph name, Query`\n\nReturns: `String representation of a query execution plan`\n\n\n\u0002wzxhzdk:3\u0003\n\n\n## GRAPH.QUERY\n\nExecutes the given query against a specified graph.\n\nArguments: `Graph name, Query`\n\nReturns: `Result set`\n\n\n\u0002wzxhzdk:4\u0003\n\n\n### Query language\n\nThe syntax is based on Neo4j's [openCypher](http://www.opencypher.org/) and currently only a subset of the language is supported.\n\nA query is composed of five parts:\n\n### Query structure\n\n- MATCH\n- WHERE\n- RETURN\n- ORDER BY\n- LIMIT\n\n#### MATCH\n\nDescribes the relationship between queried entities, it is composed of three parts:\n\n- Source node (S)\n- Relationship [R]\n- Destination node (D)\n\nCombining the three together\n`(S)-[R]-> (D)`\n\nEach graph entity node/edge can contain an alias and a label, but both can be left empty if needed.\n\nEntity structure: `alias:label {filters}` alias, label and filters are all optional.\n\nExample:\n\n\n\u0002wzxhzdk:5\u0003\n\n\n`a` is an alias for the source node, which we'll be able to refer to at different places within our query.\n\n`actor` is the label under which this node is marked.\n\n`act` is the relationship type.\n\n`m` an alias for the destination node.\n\n`movie` destination node is of \"type\" movie.\n\n`{title:\"straight outta compton\"}` requires the node's title attribute to equal \"straight outta compton\".\n\nAs such, we're interested in actor entities which have the relation \"act\" with **the** entity representing the \"straight outta compton\" movie.\n\nIt is possible to describe broader relationships by composing a multi-hop query such as:\n\n\n\u0002wzxhzdk:6\u0003\n\n\nHere we're interested in finding out who are my friends' friends.\n\nNodes can have more than one edge coming in or out of them, for instance:\n\n\n\u0002wzxhzdk:7\u0003\n\n\nHere we're interested in knowing which of my friends have visited at least one country i've been to.\n\n\n#### WHERE\n\nThis clause is not mandatory, but in order to filter results you can define predicates of two kinds:\n\n1.Compare against constant value: `alias.property operation value`\nwhere `value` is a primitive type (int, float, string and boolean)\n\n2.Compare between nodes properties: `alias.property operation alias.property`\n\nSupported operations:\n\n- `=`\n- `!=`\n- ` < `\n- ` < =`\n- `>`\n- `>=`\n\nPredicates can be combined using AND / OR. Be sure to wrap predicates within parentheses to control precedence.\n\n\nExamples:\n\n\n\u0002wzxhzdk:8\u0003\n\n\n\n\u0002wzxhzdk:9\u0003\n\n\nIt is also possible to specify equality predicates within nodes and edges using the curly braces as such:\n\n\n\u0002wzxhzdk:10\u0003\n\n\nHere we've required that the president node's name will have the value \"Barack Obama\"\nand the won edge term property will equal 2.\n\nThere's no difference between inlined predicates and predicates specified within the WHERE clause.\n\n#### RETURN\n\nIn its simple form, Return defines which properties the returned result-set will contain.\nIts structure is a list of `alias.property` seperated by commas.\nFor convenience, it's possible to specify the alias only when you're interested in every attribute an entity possesses,\nand don't want to specify each attribute individually. e.g.\n\n\n\u0002wzxhzdk:11\u0003\n\n\nUse the DISTINCT keyword to remove duplications within the result-set:\n\n\n\u0002wzxhzdk:12\u0003\n\n\nIn the above example, suppose we have two friends, Joe and Miesha,\nand both know Dominick. Then DISTINCT will make sure that Dominick will only appear once\nin the final result-set.\n\n\nReturn can also be used to aggregate data similar to SQL group by. Once an aggregation function is added to the return list, all other \"none\" aggregated values are considered as group keys, for example:\n\n\n\u0002wzxhzdk:13\u0003\n\n\nHere we group data by movie title and for each movie, we find its youngest and oldest actor age.\n\n#### Aggregations\n\nSupported aggregation functions:\n\n- `sum`\n- `avg`\n- `min`\n- `max`\n- `count`\n\n### ORDER BY\n\nSpecifies that the output should be sorted and how.\n\nYou can order by multiple properties by stating each variable in the ORDER BY clause.\nThe result will be sorted by the first variable listed, and for equal values, go to the next property in the ORDER BY clause, and so on.\n\n\n\u0002wzxhzdk:14\u0003\n\n\nBelow we sort our friends by height. For similar heights, weight is used to break even.\n\n\n\u0002wzxhzdk:15\u0003\n\n\n### LIMIT\n\nAlthough not mandatory, in order to limit the number of records returned by a query, you can\nuse the limit clause:\n\n\n\u0002wzxhzdk:16\u0003\n\n\nIf not specified, there's no limit to the number of records returned by a query.", 
            "title": "GRAPH.ADDEDGE"
        }, 
        {
            "location": "/design/", 
            "text": "RedisGraph: A High Performance In-Memory Graph Database as a Redis Module\n\n\nAbstract\n\n\nGraph based data is everywhere now days, Facebook, Google, Twitter and Pinterest are only a few who've realize the power behind relationship data and are utilizing it to the fullest, as a direct result we see a rise both in interest and variety of graph data solutions.\n\n\nWith the introduction of \nRedis Modules\n we've seen the great potential of introducing a graph data structure to Redis arsenal,\na native C implementation with emphasis on performance was developed to bring new graph database capabilities to Redis,\nthe \nRedisGraph\n is now available as an open source project on \nGitHub\n.\n\n\nIn this document we'll discuss the internal design and feature of RegisGraph and demonstrate its current capabilities.\n\n\nRediGraph At-a-Glance\n\n\nRediGraph is a graph database developed from scratch on top of Redis, using the new Redis Modules API to extend Redis with new commands and capabilities. Its main features include:\n- Simple, fast indexing and querying\n- Data stored in RAM, using memory-efficient custom data structures\n- On disk persistence\n- Tabular result sets\n- Simple and popular query language (Cypher)\n- Data Filtering, Aggregation and ordering\n\n\nA Little Taste: RediGraph in Action\n\n\nLet\u2019s look at some of the key concepts of RediGraph using this example over the redis-cli tool:\n\n\nIntroducing our entities:\n\n\nIt is a common concept to represent entities as nodes within a graph, In this example, we'll create a small graph with both actors and movies as its entities,\nan \"act\" relation will connect actors to movies they casted in.\n\n\nWe use the graph.CREATENODE command to create a new entity:\n\n\ngraph.CREATENODE \ngraph_id\n \nlabel\n \nattribute_name\n \nattribute_value\n \nattribute_name\n \nattribute_value\n ...\n\n\n\n\n\nOr in our example:\n\n\ngraph.CREATENODE IMDB actor name \nAldis Hodge\n birth_year \n1986\n\ngraph.CREATENODE IMDB actor name \nOShea Jackson\n birth_year \n1991\n\ngraph.CREATENODE IMDB actor name \nCorey Hawkins\n birth_year \n1988\n\ngraph.CREATENODE IMDB actor name \nNeil Brown\n birthyear \n1980\n\ngraph.CREATENODE IMDB movie title \nStraight Outta Compton\n genre Biography votes \n127258\n rating \n7\n.9 year \n2015\n\ngraph.CREATENODE IMDB movie title \nNever Go Back\n gener Action votes \n15821\n rating \n6\n.4 year \n2016\n\n\n\n\n\n\nConnecting entities:\n\n\nIt is now time to form relationships between actors and movies, we use RedisGraph ADDEDGE command and specify the source entity, type of connection and destination entity as such:\n\n\nGRAPH.ADDEDGE \ngraph_id\n \nsrc_entity_id\n \nrelation\n \ndest_entity_id\n\n\n\n\n\n\nAdding the Straight Outta Compton cast:\n\n\nGRAPH.ADDEDGE IMDB \nAldis_Hodge node id\n act \nStraight_Outta_Compton node id\n\nGRAPH.ADDEDGE IMDB \nOShea_Jackson node id\n act \nStraight_Outta_Compton node id\n\nGRAPH.ADDEDGE IMDB \nCorey_Hawkins node id\n act \nStraight_Outta_Compton node id\n\nGRAPH.ADDEDGE IMDB \nNeil_Brown node id\n act \nStraight_Outta_Compton node id\n\n\n\n\n\n\nAdding the only cast member who also played in the movie Never Go Back.\n\n\nGRAPH.ADDEDGE IMDB \nAldis_Hodge node id\n act \nNever_Go_Back node id\n\n\n\n\n\n\nQuerying the graph:\n\n\nRedisGraph exposes a subset of Neo4J Cypher language, although only a number of language capabilities are supported there's enough functionality to extract valuable insights from your graphs, to execute a query we use the GRAPH.QUERY command:\n\n\nGRAPH.QUERY \ngraph_id\n \nquery\n\n\n\n\n\n\nLet's execute a number of queries against our movies graph:\n\n\nFind the sum, max, min and avg age of the Straight Outta Compton cast:\n\n\nGRAPH.QUERY IMDB \nMATCH (a:actor)-[act]-\n(m:movie {title:\\\nStraight Outta Compton\\\n})\n\n\nRETURN m.title, SUM(a.age), MAX(a.age), MIN(a.age), AVG(a.age)\n\n\n\n\n\n\nRedisGraph will reply with:\n\n\n1\n)\n \nm.title, SUM(a.age), MAX(a.age), MIN(a.age), AVG(a.age)\n\n\n2\n)\n \nStraight Outta Compton,123.000000,37.000000,26.000000,30.750000\n\n\n3\n)\n \nQuery internal execution time: 0.071000 milliseconds\n\n\n\n\n\n\nThe first row is our result-set hearder which name each column according to the return clause.\nSecond row contains our query result.\nLast row contains RedisGraph execution time.\n\n\nLet's try another query, this time we'll find in how many movies each actor played.\n\n\nGRAPH.QUERY IMDB \nMATCH (actor)-[act]-\n(movie) RETURN actor.name, COUNT(movie.title) AS movies_count ORDER BY movies_count DESC\n\n\n\n1\n)\n \nactor.name, movies_count\n\n\n2\n)\n \nAldis Hodge,2.000000\n\n\n3\n)\n \nO\nShea Jackson,1.000000\n\n\n4\n)\n \nCorey Hawkins,1.000000\n\n\n5\n)\n \nNeil Brown,1.000000\n\n\n6\n)\n \nQuery internal execution time: 0.071000 milliseconds\n\n\n\n\n\n\nThe Theory: Ideas behind RedisGraph\n\n\nDifferent graph databases uses different structures for representing a graph, some use adjacency list others might use an adjacency matrix, each with its advantages and disadvantages, For RedisGraph it was crucial to find a data structure which will enable us to perform fast searches on the graph, and so we're using a concept called Hexastore to hold all relationships within a graph.\n\n\nGraph representation: Hexastore\n\n\nA Hexastore is simply a list of triplets, where each triplet is composed of three parts:\n\n\n\n\nSubject\n\n\nPredicate\n\n\nObject\n\n\n\n\nWhere the Subject refers to a source node, Predicate represents a relationship and the Object refers to a destination node.\nFor each relationship within a graph our hexastore will contain all six permutation of the source node, relationship edge and destination node, for example consider the following relation:\n\n\n(Aldis_Hodge)-[act]-\n(Straight_Outta_Compton)\n\n\nAldis_Hodge is the source node\nact is the relationship\nand Straight_Outta_Compton is the destination node.\n\n\nAll six possibilities of representing this connection are as follows:\n\n\nSPO:Aldis_Hodge:act:Straight_Outta_Compton\nSOP:Aldis_Hodge:Straight_Outta_Compton:act\nPOS:act:Straight_Outta_Compton:Aldis_Hodge\nPSO:act:Aldis_Hodge:Straight_Outta_Compton\nOPS:Straight_Outta_Compton:act:Aldis_Hodge\nOSP:Straight_Outta_Compton:Aldis_Hodge:act\n\n\n\n\n\nWith the Hexastore constructed we can easily search our graph, suppose I would like to find the cast of the movie Straight Outta Compton, all I've to do is search my Hexastore for all strings containing the prefix: \nOPS:Straight_Outta_Compton:act:*\n\n\nOr if I'm interested in all the movies Aldis Hodge played in I can search for all strings containing the prefix: \nSPO:Aldis_Hodge:act:*\n\n\nAlthough a Hexastore uses plenty of memory, six triplets for each relation, we're using a trie data structure which is not only fast in terms of search but is also memory efficient as it doesn't create duplication of string prefixes it already seen.\n\n\nQuery language: Cypher\n\n\nThere are a number of Graph Query languages, we didn't want to reinvent the wheel and come up with our own language,\nand so we've decided to implement a subset of one of the most popular graph query language out there Cypher by Neo4J,\nthe Open-Cypher project provides means to create a parser for the language, although convenient\nwe decided to create our own parser with Lex as a tokenizer and Lemon which generates a C target parser.\n\n\nAs mentioned only a subset of the language is supported, but it is our intention to continue adding new capabilities and extend the language.\n\n\nRuntime: query execution\n\n\nLet's review the steps our module takes when executing a query,\nconsider the following query which finds all actors who've played alongside Aldis Hodge and are over 30 years old:\n\n\nMATCH (aldis::actor {name:\nAldis Hodge\n})-[act]-\n(m:movie)\n-[act]-(a:actor) WHERE a.age \n 30 RETURN m.title, a.name\n\n\n\n\n\nRediGraph will\n- Parse query, build abstract syntax tree (AST)\n- Construct a query execution plan composed of:\n  - Label scan operation\n  - Filter operation (filter tree)\n  - Expand operation\n  - Expand into operation\n- Execute plan\n- Populate result-set with matching entities attributes\n\n\nQuery parser\n\n\nGiven a valid query the parser will generate an AST containing four primary nodes one for each clause:\n\n\n\n\nMATCH\n\n\nWHERE\n\n\nRETURN\n\n\nORDER\n\n\n\n\nGenerating an abstract syntax tree is a common way of discribing and structuring a language.\n\n\nFilter tree\n\n\nA query can filter out entities by creating predicates, in our example we're filtering actors which are younger then 30.\nIt's possible to combined predicates using the OR, AND keywords to form granular conditions. during runtime the WHERE clause is used\nto construct a filter tree, each node within the tree is either a condition e.g. A \n B or an operation (AND/OR), candidate entities are passed\nthrough the tree and get evaluated.\n\n\nQuery processing\n\n\nThe MATCH clause describes relations between queried entities (nodes), a node can have an alias which will allow us to refer to it\nat later stages within the executing query lifetime (WHERE, RETURN clause), but all nodes must eventually be assign an ID,\nthe process of assigning IDs to nodes is refer to as the search phase.\n\n\nDuring the search we'll be querying the Hexastore for IDs according to the MATCH clause structure,\nfor instance in our example we'll start our search by looking for movies in which Aldis Hodge played in,\nfor each movie we'll extend our search to find out which other\nactors played in the current processed movie.\n\n\nAs you might imagine the search process is a recursive operation which traverse the graph, at each step a new ID is\ndiscovered, once every node has an ID assigned to it we can be assured that current entities have passed our filters,\nat this point we can extract requested attributes (as specified in the return clause) and append a new record to the final result set.\n\n\nBenchmarks\n\n\nDepending on the underlying hardware results may vary, that said inserting a new relationship is done in O(1) RedisGraph is able to create 100K new relations within one second.\n\n\nRetrieving data really depends on the size of the graph and the type of query you're executing, on a small size graph ~1000 entities and ~2500 edges RedisGraph is able to perform ~65K friend of a friend query every second.\n\n\nIt's worth mentioning that besides the hexastore, entities are not indexed, it\u2019s our intention to introduce entities indexing which should decrease query execution time dramatically.\n\n\nLicense\n\n\nRedis-Graph is published under AGPL-3.0.\n\n\nConclusion\n\n\nRedisGraph although still a young project, can be an alternative to other graph databases, with its subset of operations one can use it to analyze and explore its graph data, being a Redis module this project is accessible from every Redis client without the need to make any adjustments. It's our intention to keep on improving and extending RedisGraph with the help of the open source community.", 
            "title": "Design"
        }, 
        {
            "location": "/design/#redisgraph-a-high-performance-in-memory-graph-database-as-a-redis-module", 
            "text": "", 
            "title": "RedisGraph: A High Performance In-Memory Graph Database as a Redis Module"
        }, 
        {
            "location": "/design/#abstract", 
            "text": "Graph based data is everywhere now days, Facebook, Google, Twitter and Pinterest are only a few who've realize the power behind relationship data and are utilizing it to the fullest, as a direct result we see a rise both in interest and variety of graph data solutions.  With the introduction of  Redis Modules  we've seen the great potential of introducing a graph data structure to Redis arsenal,\na native C implementation with emphasis on performance was developed to bring new graph database capabilities to Redis,\nthe  RedisGraph  is now available as an open source project on  GitHub .  In this document we'll discuss the internal design and feature of RegisGraph and demonstrate its current capabilities.", 
            "title": "Abstract"
        }, 
        {
            "location": "/design/#redigraph-at-a-glance", 
            "text": "RediGraph is a graph database developed from scratch on top of Redis, using the new Redis Modules API to extend Redis with new commands and capabilities. Its main features include:\n- Simple, fast indexing and querying\n- Data stored in RAM, using memory-efficient custom data structures\n- On disk persistence\n- Tabular result sets\n- Simple and popular query language (Cypher)\n- Data Filtering, Aggregation and ordering", 
            "title": "RediGraph At-a-Glance"
        }, 
        {
            "location": "/design/#a-little-taste-redigraph-in-action", 
            "text": "Let\u2019s look at some of the key concepts of RediGraph using this example over the redis-cli tool:", 
            "title": "A Little Taste: RediGraph in Action"
        }, 
        {
            "location": "/design/#introducing-our-entities", 
            "text": "It is a common concept to represent entities as nodes within a graph, In this example, we'll create a small graph with both actors and movies as its entities,\nan \"act\" relation will connect actors to movies they casted in.  We use the graph.CREATENODE command to create a new entity:  graph.CREATENODE  graph_id   label   attribute_name   attribute_value   attribute_name   attribute_value  ...  Or in our example:  graph.CREATENODE IMDB actor name  Aldis Hodge  birth_year  1986 \ngraph.CREATENODE IMDB actor name  OShea Jackson  birth_year  1991 \ngraph.CREATENODE IMDB actor name  Corey Hawkins  birth_year  1988 \ngraph.CREATENODE IMDB actor name  Neil Brown  birthyear  1980 \ngraph.CREATENODE IMDB movie title  Straight Outta Compton  genre Biography votes  127258  rating  7 .9 year  2015 \ngraph.CREATENODE IMDB movie title  Never Go Back  gener Action votes  15821  rating  6 .4 year  2016", 
            "title": "Introducing our entities:"
        }, 
        {
            "location": "/design/#connecting-entities", 
            "text": "It is now time to form relationships between actors and movies, we use RedisGraph ADDEDGE command and specify the source entity, type of connection and destination entity as such:  GRAPH.ADDEDGE  graph_id   src_entity_id   relation   dest_entity_id   Adding the Straight Outta Compton cast:  GRAPH.ADDEDGE IMDB  Aldis_Hodge node id  act  Straight_Outta_Compton node id \nGRAPH.ADDEDGE IMDB  OShea_Jackson node id  act  Straight_Outta_Compton node id \nGRAPH.ADDEDGE IMDB  Corey_Hawkins node id  act  Straight_Outta_Compton node id \nGRAPH.ADDEDGE IMDB  Neil_Brown node id  act  Straight_Outta_Compton node id   Adding the only cast member who also played in the movie Never Go Back.  GRAPH.ADDEDGE IMDB  Aldis_Hodge node id  act  Never_Go_Back node id", 
            "title": "Connecting entities:"
        }, 
        {
            "location": "/design/#querying-the-graph", 
            "text": "RedisGraph exposes a subset of Neo4J Cypher language, although only a number of language capabilities are supported there's enough functionality to extract valuable insights from your graphs, to execute a query we use the GRAPH.QUERY command:  GRAPH.QUERY  graph_id   query   Let's execute a number of queries against our movies graph:  Find the sum, max, min and avg age of the Straight Outta Compton cast:  GRAPH.QUERY IMDB  MATCH (a:actor)-[act]- (m:movie {title:\\ Straight Outta Compton\\ })  RETURN m.title, SUM(a.age), MAX(a.age), MIN(a.age), AVG(a.age)   RedisGraph will reply with:  1 )   m.title, SUM(a.age), MAX(a.age), MIN(a.age), AVG(a.age)  2 )   Straight Outta Compton,123.000000,37.000000,26.000000,30.750000  3 )   Query internal execution time: 0.071000 milliseconds   The first row is our result-set hearder which name each column according to the return clause.\nSecond row contains our query result.\nLast row contains RedisGraph execution time.  Let's try another query, this time we'll find in how many movies each actor played.  GRAPH.QUERY IMDB  MATCH (actor)-[act]- (movie) RETURN actor.name, COUNT(movie.title) AS movies_count ORDER BY movies_count DESC  1 )   actor.name, movies_count  2 )   Aldis Hodge,2.000000  3 )   O Shea Jackson,1.000000  4 )   Corey Hawkins,1.000000  5 )   Neil Brown,1.000000  6 )   Query internal execution time: 0.071000 milliseconds", 
            "title": "Querying the graph:"
        }, 
        {
            "location": "/design/#the-theory-ideas-behind-redisgraph", 
            "text": "Different graph databases uses different structures for representing a graph, some use adjacency list others might use an adjacency matrix, each with its advantages and disadvantages, For RedisGraph it was crucial to find a data structure which will enable us to perform fast searches on the graph, and so we're using a concept called Hexastore to hold all relationships within a graph.", 
            "title": "The Theory: Ideas behind RedisGraph"
        }, 
        {
            "location": "/design/#graph-representation-hexastore", 
            "text": "A Hexastore is simply a list of triplets, where each triplet is composed of three parts:   Subject  Predicate  Object   Where the Subject refers to a source node, Predicate represents a relationship and the Object refers to a destination node.\nFor each relationship within a graph our hexastore will contain all six permutation of the source node, relationship edge and destination node, for example consider the following relation:  (Aldis_Hodge)-[act]- (Straight_Outta_Compton)  Aldis_Hodge is the source node\nact is the relationship\nand Straight_Outta_Compton is the destination node.  All six possibilities of representing this connection are as follows:  SPO:Aldis_Hodge:act:Straight_Outta_Compton\nSOP:Aldis_Hodge:Straight_Outta_Compton:act\nPOS:act:Straight_Outta_Compton:Aldis_Hodge\nPSO:act:Aldis_Hodge:Straight_Outta_Compton\nOPS:Straight_Outta_Compton:act:Aldis_Hodge\nOSP:Straight_Outta_Compton:Aldis_Hodge:act  With the Hexastore constructed we can easily search our graph, suppose I would like to find the cast of the movie Straight Outta Compton, all I've to do is search my Hexastore for all strings containing the prefix:  OPS:Straight_Outta_Compton:act:*  Or if I'm interested in all the movies Aldis Hodge played in I can search for all strings containing the prefix:  SPO:Aldis_Hodge:act:*  Although a Hexastore uses plenty of memory, six triplets for each relation, we're using a trie data structure which is not only fast in terms of search but is also memory efficient as it doesn't create duplication of string prefixes it already seen.", 
            "title": "Graph representation: Hexastore"
        }, 
        {
            "location": "/design/#query-language-cypher", 
            "text": "There are a number of Graph Query languages, we didn't want to reinvent the wheel and come up with our own language,\nand so we've decided to implement a subset of one of the most popular graph query language out there Cypher by Neo4J,\nthe Open-Cypher project provides means to create a parser for the language, although convenient\nwe decided to create our own parser with Lex as a tokenizer and Lemon which generates a C target parser.  As mentioned only a subset of the language is supported, but it is our intention to continue adding new capabilities and extend the language.", 
            "title": "Query language: Cypher"
        }, 
        {
            "location": "/design/#runtime-query-execution", 
            "text": "Let's review the steps our module takes when executing a query,\nconsider the following query which finds all actors who've played alongside Aldis Hodge and are over 30 years old:  MATCH (aldis::actor {name: Aldis Hodge })-[act]- (m:movie) -[act]-(a:actor) WHERE a.age   30 RETURN m.title, a.name  RediGraph will\n- Parse query, build abstract syntax tree (AST)\n- Construct a query execution plan composed of:\n  - Label scan operation\n  - Filter operation (filter tree)\n  - Expand operation\n  - Expand into operation\n- Execute plan\n- Populate result-set with matching entities attributes", 
            "title": "Runtime: query execution"
        }, 
        {
            "location": "/design/#query-parser", 
            "text": "Given a valid query the parser will generate an AST containing four primary nodes one for each clause:   MATCH  WHERE  RETURN  ORDER   Generating an abstract syntax tree is a common way of discribing and structuring a language.", 
            "title": "Query parser"
        }, 
        {
            "location": "/design/#filter-tree", 
            "text": "A query can filter out entities by creating predicates, in our example we're filtering actors which are younger then 30.\nIt's possible to combined predicates using the OR, AND keywords to form granular conditions. during runtime the WHERE clause is used\nto construct a filter tree, each node within the tree is either a condition e.g. A   B or an operation (AND/OR), candidate entities are passed\nthrough the tree and get evaluated.", 
            "title": "Filter tree"
        }, 
        {
            "location": "/design/#query-processing", 
            "text": "The MATCH clause describes relations between queried entities (nodes), a node can have an alias which will allow us to refer to it\nat later stages within the executing query lifetime (WHERE, RETURN clause), but all nodes must eventually be assign an ID,\nthe process of assigning IDs to nodes is refer to as the search phase.  During the search we'll be querying the Hexastore for IDs according to the MATCH clause structure,\nfor instance in our example we'll start our search by looking for movies in which Aldis Hodge played in,\nfor each movie we'll extend our search to find out which other\nactors played in the current processed movie.  As you might imagine the search process is a recursive operation which traverse the graph, at each step a new ID is\ndiscovered, once every node has an ID assigned to it we can be assured that current entities have passed our filters,\nat this point we can extract requested attributes (as specified in the return clause) and append a new record to the final result set.", 
            "title": "Query processing"
        }, 
        {
            "location": "/design/#benchmarks", 
            "text": "Depending on the underlying hardware results may vary, that said inserting a new relationship is done in O(1) RedisGraph is able to create 100K new relations within one second.  Retrieving data really depends on the size of the graph and the type of query you're executing, on a small size graph ~1000 entities and ~2500 edges RedisGraph is able to perform ~65K friend of a friend query every second.  It's worth mentioning that besides the hexastore, entities are not indexed, it\u2019s our intention to introduce entities indexing which should decrease query execution time dramatically.", 
            "title": "Benchmarks"
        }, 
        {
            "location": "/design/#license", 
            "text": "Redis-Graph is published under AGPL-3.0.", 
            "title": "License"
        }, 
        {
            "location": "/design/#conclusion", 
            "text": "RedisGraph although still a young project, can be an alternative to other graph databases, with its subset of operations one can use it to analyze and explore its graph data, being a Redis module this project is accessible from every Redis client without the need to make any adjustments. It's our intention to keep on improving and extending RedisGraph with the help of the open source community.", 
            "title": "Conclusion"
        }
    ]
}